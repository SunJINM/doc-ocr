# 试卷切题问题分析与优化方案

## 一、当前问题

### 核心缺陷（test_exam_paper_analysis_vl_ocr.py:877-899）

**位置**: `PostProcessor.process()` 方法

**问题描述**:
```python
if len(question_matches) >= 2:
    # 仅记录警告，但不执行拆分！
    logger.warning("检测到合并的多道题目...")
    # 目前策略：保持原样但记录警告
    # 未来可以实现更细粒度的拆分
```

**致命问题**: 代码检测到多题合并后，只记录警告，**没有真正执行拆分操作**。

---

## 二、解决方案

### 方案一：单块多题拆分（补丁方案）

**适用场景**: 单个文本块包含多道题目（如"1. xxx 2. xxx 3. xxx"）

**核心逻辑**:
```python
if group_type == 'question' and len(block_ids) == 1:
    block = block_map[block_ids[0]]
    question_matches = PostProcessor.split_multi_question_text(block.text)

    if len(question_matches) >= 2 and is_consecutive:
        # 按题号拆分，每道题创建独立的 QuestionGroup
        for i, match in enumerate(question_matches):
            start_pos = match['start_pos']
            end_pos = question_matches[i+1]['start_pos'] if i+1 < len(question_matches) else len(block.text)
            question_text = block.text[start_pos:end_pos].strip()

            result.append(QuestionGroup(
                type='question',
                block_ids=[block_id],
                merged_bbox=block.bbox,  # 保持原块bbox
                merged_text=question_text  # 拆分后的文本
            ))
```

**局限性**:
- 多个块被误合并的情况仍无法处理
- bbox 无法精确拆分（共用同一个块的 bbox）

---

## 三、流程优化方案

### 优化方向 1: 前置约束增强（治本）

**问题根源**: VL 模型在 Prompt 中要求"每道题单独成组"，但实际执行不稳定。

**优化策略**:

#### 3.1 Prompt 优化
```python
PROMPT_TEMPLATE = """
【新增约束】
8. 严格识别题号（1. 2. 3. 或 1、2、3、或 第1题 第2题）
9. 每个 question 组的 block_ids 中，文本内容必须只包含一个题号
10. 如果一个块包含多道题，该块只能分配给第一道题
11. 图片标题明确标注题号（如"第11题图"）时，必须归属到对应题号

【示例对比】
错误: {{"type": "question", "block_ids": [10, 11, 12]}}  # 块10包含"1. xxx 2. xxx"
正确: {{"type": "question", "block_ids": [10]}}           # 只分配给题1
      {{"type": "question", "block_ids": [11, 12]}}       # 题2单独成组
"""
```

#### 3.2 模型选择
- **Qwen-VL-Max**: 理解能力强，但遵循 Prompt 约束能力一般
- **豆包 VL (Doubao)**: 测试对比效果
- **考虑 Few-Shot**: 在 Prompt 中提供 3-5 个正负例

---

### 优化方向 2: 后处理增强（兜底）

#### 2.1 多块合并检测
```python
# 检测多块被合并的情况
if group_type == 'question' and len(block_ids) > 1:
    all_texts = [block_map[bid].text for bid in block_ids]

    # 统计题号出现次数
    question_numbers = []
    for text in all_texts:
        matches = split_multi_question_text(text)
        question_numbers.extend([m['question_number'] for m in matches])

    # 如果检测到多个不同题号 → 尝试拆分
    unique_numbers = set(question_numbers)
    if len(unique_numbers) > 1:
        # 按题号重新分组
        for qnum in sorted(unique_numbers):
            # 找出包含该题号的块
            related_blocks = [bid for bid in block_ids
                            if qnum in extract_question_numbers(block_map[bid].text)]
            result.append(QuestionGroup(
                type='question',
                block_ids=related_blocks,
                ...
            ))
```

#### 2.2 图片标题识别增强
```python
# 针对"第11题图"、"第12题图"的特殊处理
def extract_question_number_from_image_title(text: str) -> Optional[int]:
    import re
    match = re.search(r'第(\d+)题图', text)
    if match:
        return int(match.group(1))
    return None

# 在分组后检查图片归属
for group in question_groups:
    for bid in group.block_ids:
        if block_map[bid].label == 'image':
            qnum = extract_question_number_from_image_title(block_map[bid].text)
            if qnum and qnum != group.question_number:
                # 重新分配到正确的题目
                logger.warning(f"图片块 {bid} 归属错误，重新分配到题目 {qnum}")
```

---

### 优化方向 3: 二阶段验证（可靠性）

#### 3.1 验证规则引擎
```python
class QuestionGroupValidator:
    """题目分组验证器"""

    @staticmethod
    def validate(groups: List[QuestionGroup], blocks: List[DetectionBlock]) -> List[str]:
        """返回验证错误列表"""
        errors = []

        for idx, group in enumerate(groups):
            if group.type != 'question':
                continue

            # 规则1: 检测多题号
            question_numbers = extract_all_question_numbers(group.merged_text)
            if len(question_numbers) > 1:
                errors.append(f"Group {idx} 包含多个题号: {question_numbers}")

            # 规则2: 检测图片标题冲突
            for bid in group.block_ids:
                block = blocks[bid]
                if block.label == 'image':
                    img_qnum = extract_question_number_from_image_title(block.text)
                    if img_qnum and img_qnum not in question_numbers:
                        errors.append(f"Group {idx} 的图片 {bid} 标题不匹配")

            # 规则3: 检测bbox异常重叠（可能是合并错误）
            # ...

        return errors
```

#### 3.2 自动修复流程
```python
def auto_fix_groups(groups, blocks, errors):
    """根据验证错误自动修复分组"""
    for error in errors:
        if "包含多个题号" in error:
            # 执行拆分
            ...
        elif "图片标题不匹配" in error:
            # 重新分配图片
            ...
    return fixed_groups
```

---

### 优化方向 4: 可视化调试增强

#### 4.1 分步可视化
```python
# 当前只有最终结果图，增加中间步骤图：
1. _vl_raw_groups.jpg          # VL 原始分组结果（不同颜色标注）
2. _vl_multi_question_warn.jpg # 标注出检测到多题的块（红色高亮）
3. _vl_split_result.jpg        # 拆分后的结果对比
```

#### 4.2 分组质量报告
```json
{
  "total_groups": 15,
  "question_groups": 12,
  "warnings": [
    {
      "type": "multi_question_detected",
      "group_id": 3,
      "question_numbers": [1, 2, 3],
      "auto_fixed": true
    },
    {
      "type": "image_title_mismatch",
      "block_id": 18,
      "expected_question": 11,
      "assigned_question": 10,
      "auto_fixed": true
    }
  ]
}
```

---

## 四、推荐实施方案

### 阶段一：快速修复（1-2小时）
1. 实现"方案一：单块多题拆分"
2. 增加验证规则引擎（仅报告，不自动修复）
3. 优化可视化输出（标注警告区域）

### 阶段二：增强稳定性（1天）
1. 优化 Prompt（增加约束和示例）
2. 实现多块合并检测
3. 实现图片标题识别增强

### 阶段三：完善生态（2-3天）
1. 二阶段验证 + 自动修复
2. 完善可视化调试工具
3. 建立测试集和回归测试

---

## 五、长期架构优化建议

### 5.1 混合策略架构
```
┌─────────────────────────────────────────┐
│         试卷结构化分析引擎              │
├─────────────────────────────────────────┤
│ Layer 1: PaddleOCR VL 粗粒度检测        │
│          ↓                              │
│ Layer 2: 规则引擎预处理（题号识别）    │
│          ↓                              │
│ Layer 3: VL 模型语义聚合                │
│          ↓                              │
│ Layer 4: 验证 + 自动修复                │
│          ↓                              │
│ Layer 5: 人工审核接口（可选）           │
└─────────────────────────────────────────┘
```

### 5.2 数据驱动优化
- 收集 100+ 真实试卷样本
- 标注"困难样本"（多题合并、图文混排）
- 建立回归测试集
- 定期评估准召率

### 5.3 模型微调方向
- 考虑基于 PaddleOCR VL 的微调
- 训练专门的"题目边界检测模型"
- Few-Shot 学习优化 VL Prompt
